<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LHDIGO</title>
  
  
  <link href="https://lhdigo.github.io/atom.xml" rel="self"/>
  
  <link href="https://lhdigo.github.io/"/>
  <updated>2023-08-30T06:54:53.000Z</updated>
  <id>https://lhdigo.github.io/</id>
  
  <author>
    <name>lhdigo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程与线程</title>
    <link href="https://lhdigo.github.io/2023/08/30/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://lhdigo.github.io/2023/08/30/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-08-30T06:54:53.000Z</published>
    <updated>2023-08-30T06:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是线程和进程？"><a href="#什么是线程和进程？" class="headerlink" title="什么是线程和进程？"></a>什么是线程和进程？</h2><blockquote><ul><li>进程是系统运行程序的基本单位</li><li>线程是进程划分的更小运行单位，是CPU调度的基本单位。一个进程在运行过程中可能会有一个或多个线程，这些线程共享着进程的堆和方法区资源，但是，线程的程序计数器、虚拟机栈、本地方法栈是私有的。</li></ul></blockquote><span id="more"></span><hr><h2 id="为何线程之间的程序计数器是私有的呢？"><a href="#为何线程之间的程序计数器是私有的呢？" class="headerlink" title="为何线程之间的程序计数器是私有的呢？"></a>为何线程之间的程序计数器是私有的呢？</h2><blockquote><p>程序计数器私有主要是为了为了线程切换回来后能够还原为正确的执行位置（顺序）</p><ul><li>字节码解释器通过改变程序计数器来依次读取执行指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常等处理。</li><li>在多线程的情况下，程序计数器能够记录当前执行的位置，从而当线程被切换回来后，能够知道上一次执行位置到哪了。</li></ul></blockquote><h2 id="线程之间虚拟机栈和本地方法栈为何是私有的呢？"><a href="#线程之间虚拟机栈和本地方法栈为何是私有的呢？" class="headerlink" title="线程之间虚拟机栈和本地方法栈为何是私有的呢？"></a>线程之间虚拟机栈和本地方法栈为何是私有的呢？</h2><p><strong>为了保证线程之间的局部变量不会被别的线程访问。</strong></p><blockquote><ul><li>虚拟机栈：运行java方法的时候，创建一个栈帧存储局部变量、操作数栈、常量池引用等信息。</li><li>本地方法栈：与虚拟机栈类似，不同的是本地方法栈是运行native方法时候…</li></ul></blockquote><hr><h2 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h2><p>方法区存储的是类的静态结构和元信息，而堆存储的是类的实例化对象及其相关数据。方法区是所有实例共享的，而堆是每个对象实例独立拥有的。</p><ol><li><p>堆：</p><ul><li>堆和方法区都是线程共享的资源，其中堆是进程中最大的一块内存，主要存储新建的对象</li><li>所有通过关键字<code>new</code>​​​创建的对象都会被分配到堆上。</li><li>堆的内存是动态分配和回收的，即对象的创建和销毁都是由垃圾回收器（Garbage Collector）自动完成的。</li><li>堆内存的大小可以通过JVM参数进行调整。</li><li>堆被所有线程共享，因此是线程安全的。</li></ul></li><li><p>方法区：</p><ul><li>方法区是Java虚拟机用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等的一块内存区域。</li><li>方法区也被称为永久代（Permanent Generation），在早期版本的JVM中，它是使用永久代来实现的。但是从JDK 8开始，永久代被元空间（Metaspace）所取代。</li><li>方法区存储的是类级别的信息，而堆存储的是对象级别的信息。</li><li>方法区的内存空间在JVM启动时被分配，并且其大小也可以通过JVM参数进行调整</li><li>方法区主要用于存储类的结构信息，如字段、方法、构造函数、父类、接口等，以及运行时常量池、静态变量等。</li></ul></li></ol><hr><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><ol><li>并发：两个及两个以上的作业在<strong>同一时间段</strong>内执行，看起来是同时执行，实际上只是cpu调度切换速度很快。单核处理器</li><li>并行：两个或两个以上的作业在<strong>同一时刻执行。</strong>多核处理器</li></ol><p>‍</p><h2 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h2><ol><li>同步：方法调用后，在没有得到返回值前，不会执行之后的方法，会一直等待。</li><li>异步：方法调用后，不用等待返回值，继续执行后续的程序。通常会通过回调、轮询或事件通知等方式获取异步方法执行的结果。</li></ol><h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h2><ol><li><p>总体：</p><ul><li>计算机底层：线程可以比作轻量级的进程，是程序执行的最小单位，线程之间的切换和调度成本远远小于进程。另外，多核cpu时代意味着多个线程可以同时运行，减少了线程上下文切换的开销。</li><li>互联网发展趋势：系统越来越大，动辄上百万级的并发量，使用多线程并发编程是开发高并发系统的基础，提高并发能力、性能。</li></ul></li><li><p>计算机底层：</p><ul><li>单核时代：为了提高单进程利用CPU和IO系统的效率。</li><li>多核时代：为了提高进程利用多核CPU的能力。</li></ul></li></ol><h2 id="多线程带来的问题？"><a href="#多线程带来的问题？" class="headerlink" title="多线程带来的问题？"></a>多线程带来的问题？</h2><ol><li>内存泄露</li><li>死锁</li><li>线程不安全…等</li></ol><h2 id="如何理解线程安全和不安全？"><a href="#如何理解线程安全和不安全？" class="headerlink" title="如何理解线程安全和不安全？"></a>如何理解线程安全和不安全？</h2><p>线程是否安全主要是：多线程访问临界资源后能否保持其的正确性和一致性。</p><p>‍</p><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>Java线程生命周期有6个状态：</p><ol><li>NEW：初始，线程被创建但未调用<code>start()</code>​</li><li>RUNNABLE：运行，线程被调用了<code>start()</code>​</li><li>BLOCKED：阻塞，需要等待锁被释放</li><li>WAITING：执行了<code>wait()</code>​方法后进入等待状态，不能自动唤醒，只能手动唤醒。</li><li>TIME_WAITING：超时等待，执行了<code>wait(long time)</code>、<code>sleep()</code>​、<code>join()</code>​方法后进入等待状态，但是可以自动唤醒。</li><li>TERMINATED：终止，线程执行完毕。</li></ol><p>​​​​<img src="https://s2.loli.net/2023/08/30/Oa7urPSLQIThqCM.png" alt="acd1b5f17a52.png">​​​​</p><h2 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换"></a>什么是线程上下文切换</h2><p>线程在执行过程中有自己的运行条件和状态（也称上下文）</p><p>线程上下文切换：保存当前线程的上下文、选择下一个需要运行的线程、等待下次占用CPU时恢复现场。</p><ul><li>主动让出CPU：调用了<code>sleep()</code>​、<code>wait()</code>​等方法。</li><li>CPU时间片用完。操作系统为了防止一个线程或则进程长时间占用CPU导致其他线程或进程“饿死”。</li><li>调用来了阻塞类型的系统终端，比如请求IO，线程被阻塞。</li><li>被终止、结束运行。</li></ul><h2 id="什么是线程死锁？如何避免？"><a href="#什么是线程死锁？如何避免？" class="headerlink" title="什么是线程死锁？如何避免？"></a>什么是线程死锁？如何避免？</h2><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><blockquote><p>两个或以上线程被同时阻塞，都在请求对方占有的资源且不释放自己占有的资源，造成无限循环等待、阻塞。</p></blockquote><p>死锁四个必要条件：</p><ol><li>互斥：一个资源每次只能被一个线程使用。</li><li>请求与保持：一个线程A因请求资源A而阻塞的时候，对已拥有的资源B一直不释放。</li><li>不剥夺：线程A已获得的资源A在未运行完毕之前，不可被其他线程强行剥夺，只能通过线程A正常使用后完毕后自己释放。</li><li>循环等待：若干个线程之间行程一种头尾相接的循环等待资源的关系。</li></ol><h3 id="预防死锁、避免死锁"><a href="#预防死锁、避免死锁" class="headerlink" title="预防死锁、避免死锁"></a>预防死锁、避免死锁</h3><p>死锁无法解决，只能预防、避免：</p><ol><li><p><strong>预防死锁：</strong>通过破坏死锁的必要条件即可：</p><ol><li>破坏请求与保持条件：一次性申请所有资源。</li><li>破坏不可剥夺条件：占用资源后如果一直申请不到其他资源，主动释放已占有的资源。</li><li>破坏循环等待条件：靠按需申请资源来预防</li></ol></li><li><p><strong>避免死锁：</strong></p><p> 避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code>​ 序列为安全序列。</p></blockquote></li></ol><h2 id="sleep-和wait-方法对比"><a href="#sleep-和wait-方法对比" class="headerlink" title="sleep()和wait()方法对比"></a>sleep()和wait()方法对比</h2><ul><li><p>共同点：两者都可以暂停线程</p></li><li><p>区别：</p><ul><li>​<code>sleep()</code>​ 没有释放锁，而<code>wait()</code>​释放了锁</li><li>​<code>wait()</code>​ 通常被用于线程间交互/通信，<code>sleep()</code>​通常被用于暂停执行。</li><li>​<code>sleep()</code>​是<code>Thread</code>​类的静态方法；<code>wait()</code>​是<code>Object</code>​类的本地方法。</li><li>​<code>sleep()</code>​调用完毕后，线程会自动唤醒；<code>wait()</code>​方法调用后，线程不会自动唤醒，需要别的线程调用同一个对象上的<code>notify()</code>​或者<code>notifyAll()</code>​方法。也可以使用<code>wait(long timeout)</code>​实现线程自动唤醒。</li></ul><p>‍</p></li></ul><h2 id="为什么-wait-​-方法不定义在-Thread-中？"><a href="#为什么-wait-​-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait()​ 方法不定义在 Thread 中？"></a>为什么 <code>wait()</code>​ 方法不定义在 Thread 中？</h2><p>wait()方法是让对象所的线程实现等待，会自动释放当前线程所占有的对象锁。每个对象都拥有对象锁，既然要释放当前线程所占有的对象锁并进入WAITING状态，自然是要操作对应的对象，而不是当前的线程。</p><h2 id="为什么-​​-sleep-​​-方法定义在-​​Thread​​-中？"><a href="#为什么-​​-sleep-​​-方法定义在-​​Thread​​-中？" class="headerlink" title="为什么 ​​**sleep()​​ 方法定义在 ​​Thread​​ 中？**"></a><strong>为什么 ​</strong>​**<code>sleep()</code><strong>​</strong>​ 方法定义在 ​<strong>​</strong><code>Thread</code><strong>​</strong>​ 中？**</h2><p>因为<code>sleep()</code>​是对线程进行暂停，只是时间调度，不涉及对象，也不需要释放对象锁。</p><p>一个线程调用sleep()不影响其他线程,而wait()会导致当前线程释放锁让其他线程有机会运行。</p><h2 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h2><p>可以，但是不建议。</p><p>正确方式应该是：</p><ol><li>创建Thread类的子类，重写run()方法。</li><li>创建Thread类的示例</li><li>调用start()方法启动线程，进入就绪状态。</li></ol><p>而直接调用run方法会导致：</p><ol><li>run()方法在当前线程执行，而不是线程中执行，失去了多线程的意义。</li></ol><p>‍</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;h2 id=&quot;什么是线程和进程？&quot;&gt;&lt;a href=&quot;#什么是线程和进程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程和进程？&quot;&gt;&lt;/a&gt;什么是线程和进程？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;进程是系统运行程序的基本单位&lt;/li&gt;
&lt;li&gt;线程是进程划分的更小运行单位，是CPU调度的基本单位。一个进程在运行过程中可能会有一个或多个线程，这些线程共享着进程的堆和方法区资源，但是，线程的程序计数器、虚拟机栈、本地方法栈是私有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="https://lhdigo.github.io/categories/Java/"/>
    
    <category term="并发" scheme="https://lhdigo.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://lhdigo.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>var let const三者区别</title>
    <link href="https://lhdigo.github.io/2021/03/21/%E5%89%8D%E7%AB%AF/JavaScript/var-let-const%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/"/>
    <id>https://lhdigo.github.io/2021/03/21/%E5%89%8D%E7%AB%AF/JavaScript/var-let-const%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/</id>
    <published>2021-03-21T00:36:53.000Z</published>
    <updated>2021-03-21T00:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h2><ul><li><code>var</code>声明的变量会挂载在window上，而<code>let</code>和<code>const</code>声明的变量不会<blockquote><p>在最外面用var声明的变量是全局变量;<br>在函数内用var声明的变量是局部变量<br>不用var声明，直接赋值的变量，是全局变量。</p><blockquote><p>注：a = 10,这种声明方式只有在这条语句执行的时候才会创建全局变量a。</p></blockquote></blockquote><span id="more"></span></li></ul><hr><h2 id="let"><a href="#let" class="headerlink" title="let"></a><code>let</code></h2><ul><li><code>let</code> 声明的变量的作用域是块级的；</li><li><code>let</code> 不能重复声明已存在的变量；</li><li><code>let</code> 有暂时死区，不会被提升。</li></ul><hr><h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><ul><li><code>const</code>声明的常量必须初始化，而let声明的变量不用</li><li><code>const</code> 定义常量的值不能通过再赋值修改，也不能再次声明。而 <code>let</code> 定义的变量值可以修改。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>var</code>：变量提升（无论声明在何处，都会被提至其所在作用于的顶部）</li><li><code>let</code>：无变量提升（未到let声明时，是无法访问该变量的）</li><li><code>const</code>：无变量提升，声明一个基本类型的时候为常量，不可修改；声明对象可以修改</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;var&quot;&gt;&lt;a href=&quot;#var&quot; class=&quot;headerlink&quot; title=&quot;var&quot;&gt;&lt;/a&gt;&lt;code&gt;var&lt;/code&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt;声明的变量会挂载在window上，而&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;声明的变量不会&lt;blockquote&gt;
&lt;p&gt;在最外面用var声明的变量是全局变量;&lt;br&gt;在函数内用var声明的变量是局部变量&lt;br&gt;不用var声明，直接赋值的变量，是全局变量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：a = 10,这种声明方式只有在这条语句执行的时候才会创建全局变量a。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="前端" scheme="https://lhdigo.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="https://lhdigo.github.io/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
    
    <category term="var" scheme="https://lhdigo.github.io/tags/var/"/>
    
    <category term="let" scheme="https://lhdigo.github.io/tags/let/"/>
    
  </entry>
  
  <entry>
    <title>Java中的锁</title>
    <link href="https://lhdigo.github.io/2020/10/19/Java%E5%9F%BA%E7%A1%80/%E9%94%81/Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://lhdigo.github.io/2020/10/19/Java%E5%9F%BA%E7%A1%80/%E9%94%81/Java%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2020-10-19T06:59:36.000Z</published>
    <updated>2020-10-19T06:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 / 非公平锁"></a>公平锁 / 非公平锁</h1><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><strong>公平锁：(FIFO)多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。</strong></p><blockquote><p>公平锁就好像在餐厅的门口安装了一个排队的护栏，谁先来的谁就站的靠前，无法进行插队，当餐厅中的人用餐结束后会把钥匙交给排在最前边的那个人，以此类推。</p><p>公平锁的好处是，可以保证每个排队的人都有饭吃，先到先吃后到后吃。</p><p>但是弊端是，<strong>要额外安装排队装置。</strong></p></blockquote><span id="more"></span><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p><strong>非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</strong></p><blockquote><p>非公平锁就是不用排队，当餐厅里的人出来后将钥匙往地上一扔，谁抢到算谁的。</p><p>但是这样就造成了一个问题，那些身强体壮的人可能总是会先抢到钥匙，而那些身体瘦小的人可能一直抢不到。</p><p>这就有可能将一直抢不到钥匙，最后导致需要很长时间才能拿到钥匙甚至一直拿不到直至饿死。</p><p><strong>非公平锁的优点在于吞吐量比公平锁大。</strong></p></blockquote><p><strong>对于<code>Synchronized</code>而言，是一种非公平锁。</strong>由于其并不像<code>ReentrantLock</code>是通过<code>AQS</code>的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><p>对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁。默认是<strong>非公平锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">    * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">       sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">    * given fairness policy.</span></span><br><span class="line"><span class="comment">    *传入true则变公平锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁 / 读写锁"></a>互斥锁 / 读写锁</h1><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><blockquote><p>互斥锁 通过<strong>悲观锁</strong>的理念引出来的；</p><p>非互斥锁  通过<strong>乐观锁</strong>的概念引申的。</p></blockquote><p>互斥锁也就是常说的<strong>同步</strong>，即一次最多只能有一个线程持有的锁，当一个线程持有该锁的时候其它线程无法进入上锁的区域。</p><p>在Java中<code>synchronized</code>就是互斥锁，从宏观概念来讲，互斥锁就是通过<strong>悲观锁</strong>的理念引出来的，而非互斥锁则是通过<strong>乐观锁</strong>的概念引申的。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong>读写锁有三种状态</strong>：<strong>读加锁</strong>状态、写加锁状态和<strong>不加锁</strong>状态</p><p><strong>读写锁在Java中的具体实现就是</strong><code>ReadWriteLock</code></p><p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p><h1 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 / 不可重入锁"></a>可重入锁 / 不可重入锁</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class）<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantDemo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Lock mLock;</span><br><span class="line"> <span class="comment">//若不是可重入锁，inner()将不会在outer()中调用。需要等待外层outer()先释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantDemo</span><span class="params">(Lock mLock)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.mLock = mLock;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">mLock.lock();</span><br><span class="line">inner();</span><br><span class="line">mLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">mLock.lock();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">mLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">   setB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="comment">//如果synchronized不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</span></span><br></pre></td></tr></table></figure><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。</p><h3 id="例子1-不可重入的自旋锁"><a href="#例子1-不可重入的自旋锁" class="headerlink" title="例子1 不可重入的自旋锁"></a>例子1 不可重入的自旋锁</h3><p>使用<strong>自旋锁</strong>来模拟一个不可重入锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁。</span></span><br><span class="line"> <span class="comment">//这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnreentrantLock</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">//这句是很经典的“自旋”语法，AtomicInteger中也有</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!owner.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       owner.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2-不可重入锁"><a href="#例子2-不可重入锁" class="headerlink" title="例子2 不可重入锁"></a>例子2 不可重入锁</h3><p>下面也是一段<strong>不可重入锁</strong>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到，当isLocked被设置为true后，在线程调用unlock()解锁之前不管线程是否已经获得锁，都只能wait()。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>  </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">        <span class="keyword">while</span>(isLocked)&#123;  </span><br><span class="line">            wait();  </span><br><span class="line">        &#125;  </span><br><span class="line">        isLocked = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;  </span><br><span class="line">        isLocked = <span class="literal">false</span>;  </span><br><span class="line">        notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 / 悲观锁"></a>乐观锁 / 悲观锁</h1><p><img src="https://i.loli.net/2020/10/19/xt3d6XGgKWhaNr5.png" alt="image-20201019203700846"></p><h2 id="乐观锁-非互斥锁"><a href="#乐观锁-非互斥锁" class="headerlink" title="乐观锁(非互斥锁)"></a>乐观锁(非互斥锁)</h2><blockquote><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可使用版本号机制和CAS算法实现。</p><p>(比较与上一次的版本号，如果一样则更新），如果失败则要继续CAS(CompareAndSet)的操作。</p></blockquote><p>乐观锁适用于<strong>多读</strong>的应用类型，这样可以提高吞吐量，像数据库提供的类似于<code>write_condition</code>机制，其实都是提供的乐观锁。</p><h2 id="CAS并不是一种实际的锁，它只是实现乐观锁的一种思想。"><a href="#CAS并不是一种实际的锁，它只是实现乐观锁的一种思想。" class="headerlink" title="CAS并不是一种实际的锁，它只是实现乐观锁的一种思想。"></a>CAS并不是一种实际的锁，它只是实现乐观锁的一种思想。</h2><p>java中的乐观锁（如自旋锁）基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。在<code>Java</code>中<code>java.util.concurrent.atomic</code>包下面的<strong>原子变量类就是使用了乐观锁的一种实现方式CAS实现的</strong>。</p><h2 id="悲观锁（互斥锁）"><a href="#悲观锁（互斥锁）" class="headerlink" title="悲观锁（互斥锁）"></a>悲观锁（互斥锁）</h2><blockquote><p>悲观锁是就是悲观思想，即认为<strong>读少写多</strong>，遇到<strong>并发写</strong>的可能性高。</p><p>每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。</p></blockquote><p>传统的关系型数据库里边就用到了很多这种锁机制，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，写锁等，都是在做操作之前先上锁。</p><p><code>Java</code>中<code>synchronized</code>和<code>ReentrantLock</code>等<strong>独占锁</strong>就是悲观锁思想的实现。</p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p><strong>自旋锁（spinlock）当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环</strong>。</p><p><strong>它是为实现保护共享资源而提出一种锁机制。</strong></p><blockquote><p>自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。</p><p><strong>无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁</strong>。</p><p>但是两者在调度机制上略有不同：</p><ul><li>对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。</li><li>对于自旋锁，不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li></ul></blockquote><h2 id="不可重入的自旋锁"><a href="#不可重入的自旋锁" class="headerlink" title="不可重入的自旋锁"></a>不可重入的自旋锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnreentrantLock</span> &#123;</span><br><span class="line">  <span class="comment">//使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁。</span></span><br><span class="line"> <span class="comment">//这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</span></span><br><span class="line">   <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">//这句是很经典的“自旋”语法，AtomicInteger中也有</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!owner.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       owner.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lock（)</code>方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用<code>unlock()</code>方法释放了该锁。</p><h2 id="可重入的自旋锁"><a href="#可重入的自旋锁" class="headerlink" title="可重入的自旋锁"></a>可重入的自旋锁</h2><p>上面的那段代码，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p><p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p><p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantSpinLock</span> &#123;</span><br><span class="line">   <span class="comment">// 利用AtomicReference来调用CAS，ar初始（内存）值是null</span></span><br><span class="line">   <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取内存值，若已取到锁（初始值为null，当内存值也为null说明取到锁了）</span></span><br><span class="line">       <span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">       <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">           <span class="comment">// DO nothing</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">cur</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="keyword">if</span> (cur == cas.get()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">               count--;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">               cas.compareAndSet(cur, <span class="literal">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a><strong>自旋锁的优点</strong></h2><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p><h2 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h2><ol><li><p>自旋锁与互斥锁都是为了实现保护资源共享的机制。</p></li><li><p>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</p></li><li><p>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</p></li></ol><h3 id="自旋锁总结"><a href="#自旋锁总结" class="headerlink" title="自旋锁总结"></a><strong>自旋锁总结</strong></h3><ol><li><p>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</p></li><li><p>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</p></li><li><p>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</p></li><li><p>自旋锁本身无法保证公平性，同时也无法保证可重入性。</p></li><li><p>基于自旋锁，可以实现具备公平性和可重入性质的锁。</p></li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><blockquote><p>两人人一起吃饭但是只有一双筷子</p><p>某一个时候，A拿了左筷子，B拿了右筷子，两人都在<strong>循环等待</strong>等待另一跟筷子，二两人都不肯放弃手中的筷子（不可剥夺）。</p></blockquote><h2 id="死锁本质原因"><a href="#死锁本质原因" class="headerlink" title="死锁本质原因"></a>死锁本质原因</h2><p>   <strong>本质原因：</strong></p><ol><li><p>系统资源有限。</p></li><li><p>进程推进顺序不合理。</p></li></ol><h2 id="形成死锁的四个必要条件"><a href="#形成死锁的四个必要条件" class="headerlink" title="形成死锁的四个必要条件"></a>形成死锁的四个必要条件</h2><ol><li><p><strong>互斥</strong>：进程要求对所分配的资源仅能给一个进程拥有</p></li><li><p><strong>不可剥夺</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走（只能是主动释放)。</p></li><li><p><strong>请求和保持</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><blockquote><p>比如：A拿了左筷子，但又想要右筷子，而右筷子在B手中。</p></blockquote></li><li><p><strong>循环等待</strong>：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有。</p><blockquote><p>比如：A等待的筷子在B手中，B等待的筷子在A手中。</p></blockquote></li></ol><h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p>活锁可以认为是一种特殊的饥饿。</p><p>活锁和死锁在表现上是一样的两个线程都<strong>没有任何进展</strong>。</p><p>但是区别在于：死锁，两个线程都处于<strong>阻塞状态</strong>，说白了就是它不会再做任何动作，我们通过查看线程状态是可以分辨出来的。</p><p>而活锁并不会阻塞，而是一直<strong>尝试去获取需要的锁</strong>，不断的try，这种情况下线程并没有阻塞所以是<strong>活的状态</strong>，我们查看线程的状态也会发现线程是正常的，但重要的是整个程序却不能继续执行了，一直在做无用功。</p><p>例子：</p><blockquote><p>两个人在窄路相遇，同时向一个方向避让，然后又向另一个方向避让，如此反复，还是不能让对方通过。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;公平锁-非公平锁&quot;&gt;&lt;a href=&quot;#公平锁-非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁 / 非公平锁&quot;&gt;&lt;/a&gt;公平锁 / 非公平锁&lt;/h1&gt;&lt;h2 id=&quot;公平锁&quot;&gt;&lt;a href=&quot;#公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁&quot;&gt;&lt;/a&gt;公平锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;公平锁：(FIFO)多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公平锁就好像在餐厅的门口安装了一个排队的护栏，谁先来的谁就站的靠前，无法进行插队，当餐厅中的人用餐结束后会把钥匙交给排在最前边的那个人，以此类推。&lt;/p&gt;
&lt;p&gt;公平锁的好处是，可以保证每个排队的人都有饭吃，先到先吃后到后吃。&lt;/p&gt;
&lt;p&gt;但是弊端是，&lt;strong&gt;要额外安装排队装置。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://lhdigo.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="锁" scheme="https://lhdigo.github.io/categories/Java%E5%9F%BA%E7%A1%80/%E9%94%81/"/>
    
    
    <category term="Java锁" scheme="https://lhdigo.github.io/tags/Java%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap(JDK1.8)底层原理</title>
    <link href="https://lhdigo.github.io/2020/10/13/Java%E5%9F%BA%E7%A1%80/HashMap/HashMap-JDK1-8-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>https://lhdigo.github.io/2020/10/13/Java%E5%9F%BA%E7%A1%80/HashMap/HashMap-JDK1-8-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2020-10-13T08:25:34.000Z</published>
    <updated>2020-10-13T08:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h1><p><img src="https://i.loli.net/2020/10/19/24qXCrapKQlVB96.png" alt="Map图">​                                    </p><blockquote><ul><li>HashMap是 Key-Value 对映射的抽象接口，该映射不包括重复的键，即一个键对应一个值。</li><li>在HashMap中，其会根据hash算法来计算key-value的存储位置并进行快速存取。</li><li>HashMap允许key和value为null</li><li>当Hash值计算元素位置时，可能会存在Hash冲突（Hash碰撞），HashMap是采用链表解决的。</li><li>HashMap的实现，在JDK7中采用的是数组+链表，JDK8中采用的是数组+链表+红黑树。</li><li>HashMap是非线程安全的，多线程同时put时候会导致数据不一致。HashTable和ConcurrentHashMap是线程安全的，在多线程情况下ConcurrentHashMap是更优的选择。</li><li>HashMap在1.7链表采用头插法避免遍历链表，多线程时扩容可能会发生死循环情况。1.8采用尾插法不会导致死循环，且引入红黑树加快查询效率。</li></ul></blockquote><span id="more"></span>    <h1 id="HashMap重要属性"><a href="#HashMap重要属性" class="headerlink" title="HashMap重要属性"></a>HashMap重要属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">  * 初始map的容量大小为16（容量必须是2的幂次倍）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">  * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">  * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">  *  Map的最大容量为2的30次方</span></span><br><span class="line"><span class="comment">  *  java中存放的是补码，1左移31位的为 16进制的0x80000000代表的是-2147483648–&gt;所以最大只能是30</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">  * Map 容量的记载因子，主要影响map的在什么时候扩容（此处为0.75，Map数组的容量大小的75%时开始扩容）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">  * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">  * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">  * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">  * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">  * shrinkage.</span></span><br><span class="line"><span class="comment">  *  当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">  * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">  * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">  *  当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">  * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">  * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">  * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">  * 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">  * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">  * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">  * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">  *  存储元素的table数组，容量总是2的幂次倍</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">  * for keySet() and values().</span></span><br><span class="line"><span class="comment">  *  存储具体元素的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">  *  map的元素个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">  * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">  * 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">  * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">  * 加载因子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HashMap-Node-lt-k-v-gt-节点"><a href="#HashMap-Node-lt-k-v-gt-节点" class="headerlink" title="HashMap Node&lt;k,v&gt;节点"></a>HashMap Node&lt;k,v&gt;节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="comment">// hash值</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">       <span class="comment">// key值</span></span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="comment">// value 值</span></span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="built_in">this</span>.hash = hash;</span><br><span class="line">           <span class="built_in">this</span>.key = key;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">           <span class="built_in">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"><span class="comment">// 重写hashCode()方法</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">           <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 重写equels方法</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap四个构造方法"><a href="#HashMap四个构造方法" class="headerlink" title="HashMap四个构造方法"></a>HashMap四个构造方法</h1><h3 id="HashMap-无参构造方法"><a href="#HashMap-无参构造方法" class="headerlink" title="HashMap() 无参构造方法"></a>HashMap() 无参构造方法</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认初始容量为16，加载因子为0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>初始容量<code>initialCapacity</code>为默认值 : 16</p><p>负载因子<code>loadFactor</code>为默认值: 0.75f </p><p>&lt;key,value&gt;对数量达到 16*0.75=12  将进行扩容，调用resize()方法</p></blockquote><p><img src="https://i.loli.net/2020/10/19/24qXCrapKQlVB96.png"></p><h3 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化map初始化的大小并制定加载因子的构造方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      加载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;<span class="number">8</span>,<span class="number">0.5</span>&gt;();</span><br></pre></td></tr></table></figure><p>初始化 <code>initCapacity</code>   8</p><p>负载因子<code>loadFactor</code>   0.5</p><p>&lt;key,value&gt;对数量达到 8*0.5=4  将进行扩容，调用resize()方法</p></blockquote><h3 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity 指定map的初始容量，默认加载因子为0.75</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子为0.75，指定一个map构建一个初始化的map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取哈希值-hash-方法"><a href="#获取哈希值-hash-方法" class="headerlink" title="获取哈希值 hash() 方法"></a>获取哈希值 hash() 方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>h&gt;&gt;&gt;16</code>  称作扰动函数</p><p>在JDK1.8的实现中，从速度、功效、质量来考虑</p><p>优化了高位运算的算法，通过hashCode()的高16位<strong>异或</strong>低16位实现</p><blockquote><p>目的：使计算出来的hash值更加不确定 来<strong>降低碰撞的概率</strong></p></blockquote><p><code>static final int hash(Object key)</code>得到的int类型的hash值</p><p>然后再通过<code>hash &amp; (table.length -1)</code>来得到该对象在Node&lt;k,v&gt;数组中保存的位置</p><blockquote><p>这就是为什么HashMap的容量必须是2的次幂倍数啦。</p><p> 例如： 2^4 = 16, 16-1=15 = 0B(1111)。</p></blockquote><p>​            <img src="https://i.loli.net/2020/10/20/8yxgZaUKSVBNL6i.png" alt="HashMap_hash"></p><h1 id="HashMap的Put方法"><a href="#HashMap的Put方法" class="headerlink" title="HashMap的Put方法"></a>HashMap的Put方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果key存在，则value将替换原来的value值并返回被替换的那个值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  返回的值为，key下被替换的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * put key，value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  key值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent 如果为true，key存在时value不予替换</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">       <span class="comment">// 检验table是否为空或者length为0，如果是则调用resize方法进行初始化</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 数组扩容</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">// 计算key对应的桶的位置是否存在存在元素，判断为null表示不存在</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 在table[i]出创建一个新节点</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123; <span class="comment">// table[i] 处已经存在了元素（Hash碰撞）</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">// 如果key值已经存在，key不为null的情况下，e记录下当前key的node节点</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">             <span class="comment">// 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123; <span class="comment">// 链表模式</span></span><br><span class="line">               <span class="comment">// 循环当前链表</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//  p.next 为null，则将p.next指向先插入的node</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                       <span class="comment">// 如果链表长度大于设定阈值长度时（默认为8），将链表尝试转换成红黑树</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//在里面还有一个条件 需要capacity==MIN_TREEIFY_CAPACITY=64才进行链表转换红黑树，否则知识进行resize()</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="comment">// 跳出循环</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// key存在，直接跳出循环进行覆盖操作</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// 表示key已经存在</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               <span class="comment">// 如果允许替换，替换原值</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">                 <span class="comment">// 访问后回调</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="comment">// 返回旧值</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// modCount加1</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">// size是否大于阈值，大于则进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">        <span class="comment">// 插入后回调</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/19/BjTQaGYDCiLhbdU.png" alt="HashMap_put()"></p><h2 id="总结put-方法"><a href="#总结put-方法" class="headerlink" title="总结put()方法"></a>总结put()方法</h2><ol><li><p><strong>table数组是否为null</strong>或**数组长度==0,**是则<code>resize()</code>扩容</p></li><li><p>执行<code>hash(Object key)</code>得到一个<code>int</code>类型的hash值。</p></li><li><p>判断table是否为空，为空表明这是第一个元素插入，则使用resize()进行扩容，初始大小默认16;</p><p>直接插入Node节点，然后跳到第5步判断<strong>是否扩容</strong>。</p></li><li><p>如果table不为空,则判断table[i]是否为空，为空则没有发生hash碰撞，直接插入node节点</p><p>然后跳到第5步,否则进行下一步。</p></li><li><p>如果table[i]不为空,则发生了hash碰撞，继续进行下面三种判断:<br>1.桶中第一个元素(数组中的结点)的<strong>hash值相等</strong>，key相等，赋值给node节点e;<br>2.hash值不相等,说明key不相等,若为<strong>红黑树</strong>，放入树中，赋值给node节点e;<br>3.hash值不相等,说明key不相等,<strong>链表</strong>，遍历链表，尾插法插入到最后，并返回node节点e。</p><p>(链表遍历里面还有长度的判断,当<strong>链表长度&gt;=8</strong>并且<strong>数组长度&gt;=64</strong>之后需要将<strong>链表转化为红黑树</strong>进行存储;</p></li><li><p>判断新插入这个值是否导致<code>size</code>已经超过了<code>threshold</code>阈值，是则进行扩容。</p></li></ol><h1 id="HashMap的get-方法"><a href="#HashMap的get-方法" class="headerlink" title="HashMap的get()方法"></a>HashMap的get()方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key获取元素</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key的hash值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="comment">//   1、HashMap中存储数据的数组table不为null；</span></span><br><span class="line">       <span class="comment">//   2、数组table长度大于0</span></span><br><span class="line">       <span class="comment">//   3、table已经创建，且通过hash值计算出的节点存放位置有节点存在；</span></span><br><span class="line">      <span class="comment">// 若上面三个条件都满足，才表示HashMap中可能有我们需要获取的元素</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 定位到元素在数组中的位置后，我们开始沿着这个位置的链表或者树开始遍历寻找</span></span><br><span class="line">          <span class="comment">// 注：JDK1.8之前，HashMap的实现是数组+链表，到1.8开始变成数组+链表+红黑树</span></span><br><span class="line">         <span class="comment">// 首先判断这个位置的第一个节点的key值是否与参数的key值相等，</span></span><br><span class="line">          <span class="comment">// 若相等，则这个节点就是我们要找的节点，将其返回</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">// 遍历链表数据</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果节点为红黑树结构，遍历数结构查询</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="comment">// 遍历链表查询</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 未查询到，返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HashMap扩容机制-resize"><a href="#HashMap扩容机制-resize" class="headerlink" title="HashMap扩容机制 resize()"></a>HashMap扩容机制 resize()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      <span class="comment">// 记录原table数组</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// 计算oldCap的大小</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">// 扩容临界值（cap * loadFactor）</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// oldCap&gt;0 表述map的buket数组已经初始化</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已经达到容量最大值，不进行扩容（Hash碰撞）</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 扩容为原来的容量的2倍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">// 左移一位（容量*2）</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 若不满足上面的oldCap &gt; 0，表示数组还未初始化</span></span><br><span class="line">       <span class="comment">// 若当前阈值不为0，则设置为当前阈值</span></span><br><span class="line">       <span class="comment">// 这是因为HashMap有两个带参构造器，可以指定初始容量，</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;       </span><br><span class="line">           <span class="comment">// 初始化为默认的容量值      </span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;   </span><br><span class="line">           <span class="comment">// 容量界线 16* 0.75</span></span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       <span class="comment">// 扩容后的数组大小</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">// 将老数组的数据重新复制与新数组中</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">// j位置存在数据</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 清空数据</span></span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                   <span class="comment">// 若table数组的j位置只有一个节点，则直接将这个节点放入新数组，</span></span><br><span class="line">                   <span class="comment">// 使用 &amp; 替代 % 计算出余数，即下标</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) </span><br><span class="line">                   <span class="comment">// 红黑树节点-执行红黑树算法（hash冲突解决）</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// 链表数据小于限制数据-执行链表结构</span></span><br><span class="line">                   <span class="comment">// 创建两个头尾节点，表示两条链表，旧数据的一条链表可能被查分到两条链表上</span></span><br><span class="line">                   <span class="comment">// // 一条下标不变的链表，一条下标+oldCap</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                            <span class="comment">// e.hash &amp; oldCap==0 原链表的索引值</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果最后一个元素为null，说明为头节点</span></span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                               <span class="comment">// 设置头结点为e</span></span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span> <span class="comment">// 头节点已经设置了元素，直接将该元素设置在尾节点的next</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               <span class="comment">// 设置当前尾节点为e</span></span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 若与原容量做与运算，结果为1，表示将这个节点放入到新数组中，下标将改变</span></span><br><span class="line">                           <span class="keyword">else</span> &#123; </span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>) <span class="comment">// 尾节点为空，说明该链表还没有值</span></span><br><span class="line">                                   <span class="comment">// 设置头结点为e</span></span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// 头节点已经设置了元素，直接将该元素设置在尾节点的next</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               <span class="comment">// 设置当前尾节点为e</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                       <span class="comment">// 所有节点遍历完后，判断下标不变的链表是否有节点在其中</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 将这条链表的最后一个节点的next指向null</span></span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           <span class="comment">// 将链表loHead放入新数组的相同位置</span></span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 将变化后的元素生成的新链表放在新的计算位置</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           <span class="comment">// 这条链表放入的位置要在原来的基础上加上oldCap</span></span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将新创建的map Tab 返回</span></span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 这有一个算法公式<code>num % 2^n == num &amp; (2^n - 1)</code>，上述resize方法执行的时候将求余运算转化为位&amp;运算。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HashMap概述&quot;&gt;&lt;a href=&quot;#HashMap概述&quot; class=&quot;headerlink&quot; title=&quot;HashMap概述&quot;&gt;&lt;/a&gt;HashMap概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/10/19/24qXCrapKQlVB96.png&quot; alt=&quot;Map图&quot;&gt;​                                    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HashMap是 Key-Value 对映射的抽象接口，该映射不包括重复的键，即一个键对应一个值。&lt;/li&gt;
&lt;li&gt;在HashMap中，其会根据hash算法来计算key-value的存储位置并进行快速存取。&lt;/li&gt;
&lt;li&gt;HashMap允许key和value为null&lt;/li&gt;
&lt;li&gt;当Hash值计算元素位置时，可能会存在Hash冲突（Hash碰撞），HashMap是采用链表解决的。&lt;/li&gt;
&lt;li&gt;HashMap的实现，在JDK7中采用的是数组+链表，JDK8中采用的是数组+链表+红黑树。&lt;/li&gt;
&lt;li&gt;HashMap是非线程安全的，多线程同时put时候会导致数据不一致。HashTable和ConcurrentHashMap是线程安全的，在多线程情况下ConcurrentHashMap是更优的选择。&lt;/li&gt;
&lt;li&gt;HashMap在1.7链表采用头插法避免遍历链表，多线程时扩容可能会发生死循环情况。1.8采用尾插法不会导致死循环，且引入红黑树加快查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://lhdigo.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="HashMap" scheme="https://lhdigo.github.io/categories/Java%E5%9F%BA%E7%A1%80/HashMap/"/>
    
    
    <category term="HashMap" scheme="https://lhdigo.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="https://lhdigo.github.io/2020/10/11/Jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://lhdigo.github.io/2020/10/11/Jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-10-11T07:56:11.000Z</published>
    <updated>2020-10-11T07:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h1><ul><li><p>类的加载指的是将<strong>类的.class文件</strong>中的<strong>二进制数据</strong>读入到<strong>内存</strong>中，将其放在运行时数据区的<strong>方法区</strong>内，然后在<strong>堆</strong>区创建一个 java.lang.Class对象，用来封装<strong>类</strong>在<strong>方法区内的数据结构</strong>。</p><p>类的加载的最终产品是位于<strong>堆区中的 Class对象</strong>， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p></li></ul><span id="more"></span><ul><li>加载.class文件的方式<ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></li></ul><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><ol><li>加载 Loading</li><li>验证 Verification</li><li>准备 Preparation</li><li>解析 Resolution                  其中  2.验证  3.准备 4.解析为<strong>连接阶段</strong></li><li>初始化 Initialization</li><li>使用 use</li><li>卸载 Unloading</li></ol><h3 id="1-加载-Loading"><a href="#1-加载-Loading" class="headerlink" title="1. 加载 Loading"></a>1. 加载 Loading</h3><blockquote><p>查找并加载类的二进制数据</p></blockquote><ul><li><p>通过一个类的<strong>全限定名</strong>来获取其定义的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时数据结构</strong>。</p></li><li><p>在Java<strong>堆</strong>中生成一个代表这个类的      java.lang.Class对象，作为对方法区中这些数据的访问入口</p></li></ul><h3 id="2-验证-Verification"><a href="#2-验证-Verification" class="headerlink" title="2. 验证 Verification"></a>2. 验证 Verification</h3><blockquote><p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，但不是必须的。</p></blockquote><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ol><p>它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h3 id="3-准备-Preparation"><a href="#3-准备-Preparation" class="headerlink" title="3. 准备 Preparation"></a>3. 准备 Preparation</h3><blockquote><p>为类的静态变量分配内存，并将其初始化为默认值</p></blockquote><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在<strong>方法区</strong>中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括<strong>类变量（static）</strong>，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在<strong>Java堆</strong>中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ol><blockquote><p>假设一个类变量的定义为： public static int value=3；</p><p>那么变量value在准备阶段过后的<strong>初始值为0</strong>，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 public static 指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p></blockquote><h3 id="4-解析-Resolution"><a href="#4-解析-Resolution" class="headerlink" title="4. 解析 Resolution"></a>4. 解析 Resolution</h3><blockquote><p>把类中的符号引用转换为直接引用<br>符号引用就是一组符号来描述目标，可以是任何字面量。<br>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p></blockquote><p>虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</p><h3 id="5-初始化-Initialization"><a href="#5-初始化-Initialization" class="headerlink" title="5. 初始化 Initialization"></a>5. 初始化 Initialization</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p><p>Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ol><p>JVM初始化步骤：</p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下6种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li></ul><h3 id="6-结束生命周期"><a href="#6-结束生命周期" class="headerlink" title="6. 结束生命周期"></a>6. 结束生命周期</h3><p>Java虚拟机将结束生命周期：</p><ol><li>执行了 System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ol><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Classloadertest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">Loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(Loader);</span><br><span class="line">        System.out.println(Loader.getParent());</span><br><span class="line">        System.out.println(Loader.getParent().getParent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@135fbaa4</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，并没有获取到 <code>ExtClassLoader</code>的父Loader，原因是 <code>BootstrapLoader</code>（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p><p>这几种类加载器的层次关系如下图所示：</p><p><img src="https://i.loli.net/2020/10/19/ClOaoyvA1zNLPp4.png" alt="双亲委派机制流程图"></p><blockquote><p>这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><h3 id="站在Java虚拟机的角度来讲，只存在两种不同的类加载器："><a href="#站在Java虚拟机的角度来讲，只存在两种不同的类加载器：" class="headerlink" title="站在Java虚拟机的角度来讲，只存在两种不同的类加载器："></a>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</h3><ol><li>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；</li><li>所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要<strong>由启动类加载器加载到内存中</strong>之后才能去加载其他的类。</li></ol><h3 id="站在Java开发人员的角度来看，类加载器可以大致划分为以下三类："><a href="#站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：" class="headerlink" title="站在Java开发人员的角度来看，类加载器可以大致划分为以下三类："></a>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</h3><p><strong>启动类加载器</strong>： <code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。<strong>启动类加载器是无法被Java程序直接引用的</strong>。</p><p>这一步会加载关键的一个类：<code>sun.misc.Launcher</code>。这个类包含了两个静态内部类：</p><p><strong>扩展类加载器</strong>： <code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。<br><strong>应用程序类加载器</strong>： <code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p><strong>不同类加载器加载的同一个类文件不相等。</strong></p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li><p>1、在执行非置信代码之前，自动验证数字签名。</p></li><li><p>2、动态地创建符合用户特定需要的定制化构建类。</p></li><li><p>3、从特定的场所取得java class，例如数据库中和网络中。</p></li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="https://i.loli.net/2020/10/19/Nbu4arm1oE7jclz.png" alt="双亲委派机制流程"></p><ul><li>当前ClassLoader首先从<strong>自己</strong>已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</li><li>一个类加载器收到了类加载请求，不会自己立刻尝试加载类，而是把请求委托给父加载器去完成，每一层都是如此，所有的加载请求最终都传递到最顶层的类加载器进行处理；</li><li>如果父加载器不存在，那么尝试判断有没有被<strong>启动类加载器</strong>加载；</li><li>如果<strong>启动类加载器</strong>也没有加载此类，则自己尝试加载它，并放入自己加载类的缓存中。</li></ul><h4 id="如何判为什么断类是否重复加载"><a href="#如何判为什么断类是否重复加载" class="headerlink" title="如何判为什么断类是否重复加载"></a>如何判为什么断类是否重复加载</h4><p>JVM比较</p><ol><li><strong>类是否相等</strong></li><li>加载这两个类的<strong>类加载器</strong>是否相等，</li></ol><p>只有同时满足条件，两个类才能被认定是相等。</p><h4 id="为什么要有这么复杂的双亲委派机制"><a href="#为什么要有这么复杂的双亲委派机制" class="headerlink" title="为什么要有这么复杂的双亲委派机制"></a>为什么要有这么复杂的双亲委派机制</h4><blockquote><p>为什么要有这么复杂的双亲委派机制？</p><p>  如果没有这种机制，我们就可以篡改启动类加载器中需要的类了，如，修自己编写一个<code>java.lang.Object</code>用自己的类加载器进行加载，系统中就会存在多个Object类，这样Java类型体系最基本的行为也就无法保证了。</p></blockquote><h4 id="双亲委派模型特点："><a href="#双亲委派模型特点：" class="headerlink" title="双亲委派模型特点："></a>双亲委派模型特点：</h4><ul><li><p>父加载器中加载的类对于所有子加载器可见。</p></li><li><p>子类之间各自加载的类对于各自是不可间的（达到隔离效果）。</p></li><li><p>类是唯一的，没有重复的类。</p></li></ul><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><h3 id="类加载有三种方式："><a href="#类加载有三种方式：" class="headerlink" title="类加载有三种方式："></a>类加载有三种方式：</h3><ul><li><p>1、由 new 关键字创建一个类的实例（静态加载）</p></li><li><p>2、通过Class.forName()方法动态加载，通过反射加载类型，并创建对象实例</p><p>如：Class clazz ＝ Class.forName（“Dog”）；<br>Object dog ＝clazz.newInstance（）；</p></li><li><p>3、通过ClassLoader.loadClass()方法动态加载</p><p>如：Class clazz ＝ classLoader.loadClass（“Dog”）；<br>Object dog ＝clazz.newInstance（）；</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loaderTest</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//class.forName 加载方式</span></span><br><span class="line">            Class&lt;?&gt; classForName = Class.forName(<span class="string">&quot;com.lhdigo.TestClass&quot;</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor1 = classForName.getConstructor(String.class);</span><br><span class="line">            constructor1.newInstance(<span class="string">&quot;加载方式Class.forName:有一个参数的构造器&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//loader加载方式</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">            Class&lt;?&gt; classLoaderClass = classLoader.loadClass(<span class="string">&quot;com.lhdigo.TestClass&quot;</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor2 = classLoaderClass.getConstructor(String.class);</span><br><span class="line">            constructor2.newInstance(<span class="string">&quot;加载方式ClassLoader:有一个参数的构造器&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三者的区别："><a href="#三者的区别：" class="headerlink" title="三者的区别："></a>三者的区别：</h3><ul><li>1和2使用的类加载器是相同的，都是当前类加载器。（即：<code>this.getClass().getClassLoader()</code>）。</li><li>3由用户<strong>指定类加载器</strong>。如果需要在当前类路径以外寻找类，则只能采用第3种方式。第3种方式加载的类与当前类分属不同的命名空间。</li></ul><h3 id="Class-forName与ClassLoader-loadClass区别"><a href="#Class-forName与ClassLoader-loadClass区别" class="headerlink" title="Class.forName与ClassLoader.loadClass区别"></a>Class.forName与ClassLoader.loadClass区别</h3><p>首先，我们知道，Class的装载包括3个步骤：</p><p><strong>加载（loading）,连接（link）,初始化（initialize）</strong>.(连接包括：验证 准备 解析)</p><ul><li><p><code>Class.forName(className)</code>实际上是调用</p><p><code>Class.forName(className, true, this.getClass().getClassLoader())</code>。</p></li></ul><p>第二个参数，是指Class被loading后是不是必须被初始化。</p><ul><li><code>ClassLoader.loadClass(className)</code>实际上调用的是<code>ClassLoader.loadClass(name, false)</code>，第二个参数指Class是否被link。</li></ul><p><strong>总结</strong>：</p><ul><li><code>Class.forName</code>得到的<code>class</code>是已经<strong>初始化</strong>。</li><li><code>ClassLoader.loadeClass</code>得到的<code>class</code>是还<strong>没有连接</strong>的。</li></ul><h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><h3 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a><strong>为什么要自定义类加载器？</strong></h3><ol><li>加密：.class文件可以轻易的被<strong>反编译</strong>，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</li><li>从非标准的来源加载代码：如果你的.class文件是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</li></ol><p>如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类</p><h3 id="自定义类加载器步骤："><a href="#自定义类加载器步骤：" class="headerlink" title="自定义类加载器步骤："></a>自定义类加载器步骤：</h3><p>1 继承ClassLoader抽象类</p><p>2 重写findClass() </p><p>3 重写的findClass()中调用defineClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhdigo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> root + File.separatorChar + className.replace(<span class="string">&#x27;.&#x27;</span>,File.separatorChar )+ <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(String root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        myClassLoader.setRoot(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; testClass  = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = myClassLoader.loadClass(<span class="string">&quot;com.lhdigo.TestClass&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line">            System.out.println(o.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。</p><ul><li>这里传递的文件名需要是类的全限定性名称，即 <code>com.lhdigo.TestClass</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</li><li>2、最好不要重写<code>loadClass</code>方法，因为这样容易破坏双亲委托模式。</li><li>3、这类<code>TestClass</code>类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlink&quot; title=&quot;什么是类的加载&quot;&gt;&lt;/a&gt;什么是类的加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类的加载指的是将&lt;strong&gt;类的.class文件&lt;/strong&gt;中的&lt;strong&gt;二进制数据&lt;/strong&gt;读入到&lt;strong&gt;内存&lt;/strong&gt;中，将其放在运行时数据区的&lt;strong&gt;方法区&lt;/strong&gt;内，然后在&lt;strong&gt;堆&lt;/strong&gt;区创建一个 java.lang.Class对象，用来封装&lt;strong&gt;类&lt;/strong&gt;在&lt;strong&gt;方法区内的数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;类的加载的最终产品是位于&lt;strong&gt;堆区中的 Class对象&lt;/strong&gt;， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Jvm" scheme="https://lhdigo.github.io/categories/Jvm/"/>
    
    <category term="类的加载" scheme="https://lhdigo.github.io/categories/Jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    
    
    <category term="jvm类加载" scheme="https://lhdigo.github.io/tags/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC执行流程</title>
    <link href="https://lhdigo.github.io/2020/10/10/SpringFramework/SpringMVC/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://lhdigo.github.io/2020/10/10/SpringFramework/SpringMVC/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2020-10-10T15:19:09.000Z</published>
    <updated>2020-10-10T15:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC执行流程图"><a href="#SpringMVC执行流程图" class="headerlink" title="SpringMVC执行流程图"></a>SpringMVC执行流程图</h1><p><img src="https://i.loli.net/2020/10/19/SytjFUTe3nJiWEm.jpg" alt="SpringMVC执行流程图"></p><span id="more"></span><h1 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h1><ol><li>用户发送请求至前端控制器 <strong>DispatcherServlet。</strong></li><li><strong>DispatcherServlet</strong> 收到请求调用 <strong>HandlerMapping</strong> 处理器映射器。</li><li>处理器映射器 <strong>HandlerMapping</strong> 找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 <strong>DispatcherServlet</strong>。</li><li>前端控制器 <strong>DispatcherServlet。</strong>请求<strong>HandlerAdapter</strong>执行<strong>Handler</strong></li><li> <strong>HandlerAdapter</strong> 经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li> Controller执行完成返回 <strong>ModelAndView</strong>。</li><li><strong>HandlerAdapter</strong> 将controller执行结果 <strong>ModelAndView</strong> 返回给 <strong>DispatcherServlet</strong>。</li><li><strong>DispatcherServlet</strong> 将 <strong>ModelAndView</strong> 传给 <strong>ViewReslover</strong> 视图解析器。</li><li><strong>ViewReslover</strong> 解析后返回具体View。</li><li><strong>DispatcherServlet</strong> 根据View进行渲染视图（即将模型数据填充至视图中）。</li><li><strong>DispatcherServlet</strong> 响应用户。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringMVC执行流程图&quot;&gt;&lt;a href=&quot;#SpringMVC执行流程图&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC执行流程图&quot;&gt;&lt;/a&gt;SpringMVC执行流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/10/19/SytjFUTe3nJiWEm.jpg&quot; alt=&quot;SpringMVC执行流程图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SpringFramework" scheme="https://lhdigo.github.io/categories/SpringFramework/"/>
    
    <category term="SpringMVC" scheme="https://lhdigo.github.io/categories/SpringFramework/SpringMVC/"/>
    
    
    <category term="SpringMVC" scheme="https://lhdigo.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务的传播机制</title>
    <link href="https://lhdigo.github.io/2020/10/10/SpringFramework/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>https://lhdigo.github.io/2020/10/10/SpringFramework/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-10-10T13:09:07.000Z</published>
    <updated>2020-10-10T13:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring事务的配置方式"><a href="#Spring事务的配置方式" class="headerlink" title="Spring事务的配置方式"></a>Spring事务的配置方式</h1><h2 id="1-编程式事务管理"><a href="#1-编程式事务管理" class="headerlink" title="1. 编程式事务管理"></a>1. 编程式事务管理</h2><p>编程式事务管理是<strong>侵入性</strong>事务管理，粒度为<strong>代码块</strong>。</p><p>使用<code>TransactionTemplate</code>或者直接使用<code>PlatformTransactionManager</code>，对于编程式事务管理，Spring推荐使用<code>TransactionTemplate</code>。</p><span id="more"></span><h2 id="2-声明式事务管理"><a href="#2-声明式事务管理" class="headerlink" title="2. 声明式事务管理"></a>2. 声明式事务管理</h2><p>声明式事务，<strong>非侵入式</strong>，建立在<strong>AOP</strong>之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。</p><p>实现方式：配置文件中做事务声明/注解；</p><p>粒度为<strong>方法</strong>级别（不足）；</p><h1 id="Spring事务的传播机制"><a href="#Spring事务的传播机制" class="headerlink" title="Spring事务的传播机制"></a>Spring事务的传播机制</h1><h2 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1. PROPAGATION_REQUIRED"></a>1. PROPAGATION_REQUIRED</h2><p>默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。</p><h2 id="2-PROPAGATION-SUPPORTS"><a href="#2-PROPAGATION-SUPPORTS" class="headerlink" title="2. PROPAGATION_SUPPORTS"></a>2. PROPAGATION_SUPPORTS</h2><p>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p><strong>完全依赖外层的事务</strong></p><h2 id="3-PROPAGATION-NOT-SUPPORTED"><a href="#3-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="3. PROPAGATION_NOT_SUPPORTED"></a>3. PROPAGATION_NOT_SUPPORTED</h2><p>总是以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码</p><h2 id="4-PROPAGATION-REQUIRES-NEW"><a href="#4-PROPAGATION-REQUIRES-NEW" class="headerlink" title="4. PROPAGATION_REQUIRES_NEW"></a>4. PROPAGATION_REQUIRES_NEW</h2><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。当新事务执行完毕，恢复上层事务的执行。</p><h2 id="5-PROPAGATION-NEVER"><a href="#5-PROPAGATION-NEVER" class="headerlink" title="5. PROPAGATION_NEVER"></a>5. PROPAGATION_NEVER</h2><p>以非事务方式运行，如果当前存在事务，则抛出异常。</p><h2 id="6-PROPAGATION-MANDATORY"><a href="#6-PROPAGATION-MANDATORY" class="headerlink" title="6. PROPAGATION_MANDATORY"></a>6. PROPAGATION_MANDATORY</h2><p>与NEVER相反，若外层无事务，则抛出异常。若当前存在事务，则加入该事务；</p><h2 id="7-PROPAGATION-NESTED"><a href="#7-PROPAGATION-NESTED" class="headerlink" title="7. PROPAGATION_NESTED"></a>7. PROPAGATION_NESTED</h2><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，等价于<code>PROPAGATION_REQUIRED</code></p><blockquote><p>子事务回滚，父事务可选择性回滚或者不会滚</p><p>父事务回滚，子事务一定回滚</p></blockquote><p>该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring事务的配置方式&quot;&gt;&lt;a href=&quot;#Spring事务的配置方式&quot; class=&quot;headerlink&quot; title=&quot;Spring事务的配置方式&quot;&gt;&lt;/a&gt;Spring事务的配置方式&lt;/h1&gt;&lt;h2 id=&quot;1-编程式事务管理&quot;&gt;&lt;a href=&quot;#1-编程式事务管理&quot; class=&quot;headerlink&quot; title=&quot;1. 编程式事务管理&quot;&gt;&lt;/a&gt;1. 编程式事务管理&lt;/h2&gt;&lt;p&gt;编程式事务管理是&lt;strong&gt;侵入性&lt;/strong&gt;事务管理，粒度为&lt;strong&gt;代码块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;TransactionTemplate&lt;/code&gt;或者直接使用&lt;code&gt;PlatformTransactionManager&lt;/code&gt;，对于编程式事务管理，Spring推荐使用&lt;code&gt;TransactionTemplate&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringFramework" scheme="https://lhdigo.github.io/categories/SpringFramework/"/>
    
    <category term="Spring" scheme="https://lhdigo.github.io/categories/SpringFramework/Spring/"/>
    
    
    <category term="Spring" scheme="https://lhdigo.github.io/tags/Spring/"/>
    
    <category term="事务" scheme="https://lhdigo.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>事务ACID特性及四大隔离机制</title>
    <link href="https://lhdigo.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1ACID%E7%89%B9%E6%80%A7%E5%8F%8A%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/"/>
    <id>https://lhdigo.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1ACID%E7%89%B9%E6%80%A7%E5%8F%8A%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-30T15:10:16.000Z</published>
    <updated>2020-09-30T15:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACID四特性"><a href="#ACID四特性" class="headerlink" title="ACID四特性"></a>ACID四特性</h1><h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity: 原子性"></a>Atomicity: 原子性</h2><p>整个事务是一个独立的单元，要么操作成功，要么操作不成功回滚。</p><span id="more"></span><h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency: 一致性"></a>Consistency: 一致性</h2><p>事务执行的前后都是合法的数据状态，数据库的完整性约束没有被破坏。如</p><p>实体完整性（如行的主键存在且唯一）</p><p>列完整性（如字段的类型、大小、长度要符合要求）</p><p>外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</p><h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation: 隔离性"></a>Isolation: 隔离性</h2><p>事务是并发控制机制，他们的交错也需要一致性，隔离隐藏，一般通过悲观或者乐观锁实现</p><p>在并发环境当中，当<strong>不同的事务访问相同的数据时</strong>，每个事务都有<strong>各自的完整的数据空间</strong>。</p><p>由于并发事务所做的修改必须与并发的其他事务的修改隔离，所以事务查看数据更新时，数据所处的状态要么是另一个事务<strong>开始前</strong>的状态，要么就是另一个事务<strong>结束后</strong>的状态，不会查看到中间状态数据。</p><h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability: 持久性"></a>Durability: 持久性</h2><p>一个成功的事务将永久性地改变系统的状态，接下来的其他操作或故障不应该对其有任何影响。</p><hr><h1 id="四大隔离机制"><a href="#四大隔离机制" class="headerlink" title="四大隔离机制"></a>四大隔离机制</h1><h2 id="1、Read-Uncommitted-读未提交"><a href="#1、Read-Uncommitted-读未提交" class="headerlink" title="1、Read Uncommitted 读未提交"></a>1、Read Uncommitted 读未提交</h2><p><strong>脏读现象</strong>  ：事务对数据的修改，即使没提交，其他事务也能看见。</p><p>eg: 事务A读取了事务B的更新的数据，但是事务B回滚了，导致A读取的为脏数据。</p><h2 id="2、Read-Commit-读已提交"><a href="#2、Read-Commit-读已提交" class="headerlink" title="2、Read Commit      读已提交"></a>2、Read Commit      读已提交</h2><p>读取到的记录加锁，<strong>不可重复读</strong>。 要commit 其他事务才能看见最新值</p><p>eg:  在事务A中先后两次读取同一个数据，两次读取的结果不一样。</p><p>脏读与不可重复读的<strong>区别</strong>在于：</p><p>前者读到的是其他事务未提交的数据，</p><p>后者读到的是其他事务已提交的数据。</p><p>​    </p><h2 id="3、Repeatable-Read-可重复读"><a href="#3、Repeatable-Read-可重复读" class="headerlink" title="3、Repeatable Read 可重复读"></a>3、Repeatable Read 可重复读</h2><p>Mysql（InnoDB）默认隔离机制，解决了脏读，不可重复读。</p><p>但是存在<strong>幻影</strong>读现象：    一事务修改并提交数据，但其他事物读取的数据不是最新的</p><p>eg:  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读</p><p><strong>不可重复读</strong>与<strong>幻读</strong>的区别可以通俗的理解为：前者是<strong>数据</strong>变了，后者是数据的<strong>行数</strong>变了。</p><h2 id="4、Serializable串行化"><a href="#4、Serializable串行化" class="headerlink" title="4、Serializable串行化"></a>4、Serializable串行化</h2><p>解决了脏读、不可重复读和幻读的现象。但是效率低下。</p><p>它是最严格的事务隔离级别，要求所有事务被<strong>串行</strong>执行，即事务只能一个接一个的进行处理，不能并发执行。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ACID四特性&quot;&gt;&lt;a href=&quot;#ACID四特性&quot; class=&quot;headerlink&quot; title=&quot;ACID四特性&quot;&gt;&lt;/a&gt;ACID四特性&lt;/h1&gt;&lt;h2 id=&quot;Atomicity-原子性&quot;&gt;&lt;a href=&quot;#Atomicity-原子性&quot; class=&quot;headerlink&quot; title=&quot;Atomicity: 原子性&quot;&gt;&lt;/a&gt;Atomicity: 原子性&lt;/h2&gt;&lt;p&gt;整个事务是一个独立的单元，要么操作成功，要么操作不成功回滚。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://lhdigo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="https://lhdigo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="事务" scheme="https://lhdigo.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="ACID" scheme="https://lhdigo.github.io/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="https://lhdigo.github.io/2020/09/30/HelloWorld/HelloWorld/"/>
    <id>https://lhdigo.github.io/2020/09/30/HelloWorld/HelloWorld/</id>
    <published>2020-09-30T12:06:10.000Z</published>
    <updated>2020-09-30T12:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><h2 id="据说第一篇文章是Hello-World会带来好运噢"><a href="#据说第一篇文章是Hello-World会带来好运噢" class="headerlink" title="据说第一篇文章是Hello World会带来好运噢 ^^"></a>据说第一篇文章是Hello World会带来好运噢 ^^</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HelloWorld&quot;&gt;&lt;a href=&quot;#HelloWorld&quot; class=&quot;headerlink&quot; title=&quot;HelloWorld&quot;&gt;&lt;/a&gt;HelloWorld&lt;/h1&gt;&lt;h2 id=&quot;据说第一篇文章是Hello-World会带来好运噢&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="HelloWorld" scheme="https://lhdigo.github.io/categories/HelloWorld/"/>
    
    
    <category term="HelloWorld" scheme="https://lhdigo.github.io/tags/HelloWorld/"/>
    
  </entry>
  
</feed>
