---
title: 事务ACID特性及四大隔离机制
date: 2020-09-30 23:10:16
tags: 
	- 事务
	- ACID
categories: [数据库,事务]
---

# ACID四特性

## Atomicity: 原子性

整个事务是一个独立的单元，要么操作成功，要么操作不成功回滚。

<!-- more -->

## Consistency: 一致性

事务执行的前后都是合法的数据状态，数据库的完整性约束没有被破坏。如

实体完整性（如行的主键存在且唯一）

列完整性（如字段的类型、大小、长度要符合要求）

外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。



## Isolation: 隔离性  
事务是并发控制机制，他们的交错也需要一致性，隔离隐藏，一般通过悲观或者乐观锁实现

在并发环境当中，当**不同的事务访问相同的数据时**，每个事务都有**各自的完整的数据空间**。

由于并发事务所做的修改必须与并发的其他事务的修改隔离，所以事务查看数据更新时，数据所处的状态要么是另一个事务**开始前**的状态，要么就是另一个事务**结束后**的状态，不会查看到中间状态数据。



## Durability: 持久性  
一个成功的事务将永久性地改变系统的状态，接下来的其他操作或故障不应该对其有任何影响。



------



# 四大隔离机制

## 1、Read Uncommitted 读未提交   

**脏读现象**  ：事务对数据的修改，即使没提交，其他事务也能看见。

eg: 事务A读取了事务B的更新的数据，但是事务B回滚了，导致A读取的为脏数据。



## 2、Read Commit      读已提交

读取到的记录加锁，**不可重复读**。 要commit 其他事务才能看见最新值

eg:  在事务A中先后两次读取同一个数据，两次读取的结果不一样。

脏读与不可重复读的**区别**在于：

前者读到的是其他事务未提交的数据，

后者读到的是其他事务已提交的数据。




​	

## 3、Repeatable Read 可重复读

Mysql（InnoDB）默认隔离机制，解决了脏读，不可重复读。

但是存在**幻影**读现象：	一事务修改并提交数据，但其他事物读取的数据不是最新的

eg:  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读

**不可重复读**与**幻读**的区别可以通俗的理解为：前者是**数据**变了，后者是数据的**行数**变了。

## 4、Serializable串行化 

解决了脏读、不可重复读和幻读的现象。但是效率低下。

它是最严格的事务隔离级别，要求所有事务被**串行**执行，即事务只能一个接一个的进行处理，不能并发执行。

