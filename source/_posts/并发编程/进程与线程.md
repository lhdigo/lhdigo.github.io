---
title: 进程与线程
date: 2023-08-30 14:54:53
tags: [并发编程]
categories: [Java,并发]
---

# 进程与线程

## 什么是线程和进程？

> * 进程是系统运行程序的基本单位
> * 线程是进程划分的更小运行单位，是CPU调度的基本单位。一个进程在运行过程中可能会有一个或多个线程，这些线程共享着进程的堆和方法区资源，但是，线程的程序计数器、虚拟机栈、本地方法栈是私有的。
<!-- more -->
---

## 为何线程之间的程序计数器是私有的呢？

> 程序计数器私有主要是为了为了线程切换回来后能够还原为正确的执行位置（顺序）
>
> * 字节码解释器通过改变程序计数器来依次读取执行指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常等处理。
> * 在多线程的情况下，程序计数器能够记录当前执行的位置，从而当线程被切换回来后，能够知道上一次执行位置到哪了。

## 线程之间虚拟机栈和本地方法栈为何是私有的呢？

**为了保证线程之间的局部变量不会被别的线程访问。**

> * 虚拟机栈：运行java方法的时候，创建一个栈帧存储局部变量、操作数栈、常量池引用等信息。
> * 本地方法栈：与虚拟机栈类似，不同的是本地方法栈是运行native方法时候...

---

## 堆和方法区

方法区存储的是类的静态结构和元信息，而堆存储的是类的实例化对象及其相关数据。方法区是所有实例共享的，而堆是每个对象实例独立拥有的。

1. 堆：

    * 堆和方法区都是线程共享的资源，其中堆是进程中最大的一块内存，主要存储新建的对象
    * 所有通过关键字`new`​​​创建的对象都会被分配到堆上。
    * 堆的内存是动态分配和回收的，即对象的创建和销毁都是由垃圾回收器（Garbage Collector）自动完成的。
    * 堆内存的大小可以通过JVM参数进行调整。
    * 堆被所有线程共享，因此是线程安全的。

2. 方法区：

    * 方法区是Java虚拟机用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等的一块内存区域。
    * 方法区也被称为永久代（Permanent Generation），在早期版本的JVM中，它是使用永久代来实现的。但是从JDK 8开始，永久代被元空间（Metaspace）所取代。
    * 方法区存储的是类级别的信息，而堆存储的是对象级别的信息。
    * 方法区的内存空间在JVM启动时被分配，并且其大小也可以通过JVM参数进行调整
    * 方法区主要用于存储类的结构信息，如字段、方法、构造函数、父类、接口等，以及运行时常量池、静态变量等。

---

## 并发和并行的区别

1. 并发：两个及两个以上的作业在**同一时间段**内执行，看起来是同时执行，实际上只是cpu调度切换速度很快。单核处理器
2. 并行：两个或两个以上的作业在**同一时刻执行。**多核处理器

‍

## 同步和异步的区别

1. 同步：方法调用后，在没有得到返回值前，不会执行之后的方法，会一直等待。
2. 异步：方法调用后，不用等待返回值，继续执行后续的程序。通常会通过回调、轮询或事件通知等方式获取异步方法执行的结果。

## 为什么要使用多线程?

1. 总体：

    * 计算机底层：线程可以比作轻量级的进程，是程序执行的最小单位，线程之间的切换和调度成本远远小于进程。另外，多核cpu时代意味着多个线程可以同时运行，减少了线程上下文切换的开销。
    * 互联网发展趋势：系统越来越大，动辄上百万级的并发量，使用多线程并发编程是开发高并发系统的基础，提高并发能力、性能。
2. 计算机底层：

    * 单核时代：为了提高单进程利用CPU和IO系统的效率。
    * 多核时代：为了提高进程利用多核CPU的能力。

## 多线程带来的问题？

1. 内存泄露
2. 死锁
3. 线程不安全...等

## 如何理解线程安全和不安全？

线程是否安全主要是：多线程访问临界资源后能否保持其的正确性和一致性。

‍

## 线程的生命周期和状态

Java线程生命周期有6个状态：

1. NEW：初始，线程被创建但未调用`start()`​
2. RUNNABLE：运行，线程被调用了`start()`​
3. BLOCKED：阻塞，需要等待锁被释放
4. WAITING：执行了`wait()`​方法后进入等待状态，不能自动唤醒，只能手动唤醒。
5. TIME_WAITING：超时等待，执行了`wait(long time)`、`sleep()`​、`join()`​方法后进入等待状态，但是可以自动唤醒。
6. TERMINATED：终止，线程执行完毕。

​​​​![acd1b5f17a52.png](https://s2.loli.net/2023/08/30/Oa7urPSLQIThqCM.png)​​​​

## 什么是线程上下文切换

线程在执行过程中有自己的运行条件和状态（也称上下文）

线程上下文切换：保存当前线程的上下文、选择下一个需要运行的线程、等待下次占用CPU时恢复现场。

* 主动让出CPU：调用了`sleep()`​、`wait()`​等方法。
* CPU时间片用完。操作系统为了防止一个线程或则进程长时间占用CPU导致其他线程或进程“饿死”。
* 调用来了阻塞类型的系统终端，比如请求IO，线程被阻塞。
* 被终止、结束运行。

## 什么是线程死锁？如何避免？

### 线程死锁

> 两个或以上线程被同时阻塞，都在请求对方占有的资源且不释放自己占有的资源，造成无限循环等待、阻塞。

死锁四个必要条件：

1. 互斥：一个资源每次只能被一个线程使用。
2. 请求与保持：一个线程A因请求资源A而阻塞的时候，对已拥有的资源B一直不释放。
3. 不剥夺：线程A已获得的资源A在未运行完毕之前，不可被其他线程强行剥夺，只能通过线程A正常使用后完毕后自己释放。
4. 循环等待：若干个线程之间行程一种头尾相接的循环等待资源的关系。

### 预防死锁、避免死锁

死锁无法解决，只能预防、避免：

1. **预防死锁：**通过破坏死锁的必要条件即可：

    1. 破坏请求与保持条件：一次性申请所有资源。
    2. 破坏不可剥夺条件：占用资源后如果一直申请不到其他资源，主动释放已占有的资源。
    3. 破坏循环等待条件：靠按需申请资源来预防
2. **避免死锁：**

    避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

    > **安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>`​ 序列为安全序列。
    >

## sleep()和wait()方法对比

* 共同点：两者都可以暂停线程

* 区别：

  * ​`sleep()`​ 没有释放锁，而`wait()`​释放了锁
  * ​`wait()`​ 通常被用于线程间交互/通信，`sleep()`​通常被用于暂停执行。
  * ​`sleep()`​是`Thread`​类的静态方法；`wait()`​是`Object`​类的本地方法。
  * ​`sleep()`​调用完毕后，线程会自动唤醒；`wait()`​方法调用后，线程不会自动唤醒，需要别的线程调用同一个对象上的`notify()`​或者`notifyAll()`​方法。也可以使用`wait(long timeout)`​实现线程自动唤醒。

  ‍

## 为什么 `wait()`​ 方法不定义在 Thread 中？

wait()方法是让对象所的线程实现等待，会自动释放当前线程所占有的对象锁。每个对象都拥有对象锁，既然要释放当前线程所占有的对象锁并进入WAITING状态，自然是要操作对应的对象，而不是当前的线程。

## **为什么 ​**​**`sleep()`**​**​ 方法定义在 ​**​**`Thread`**​**​ 中？**

因为`sleep()`​是对线程进行暂停，只是时间调度，不涉及对象，也不需要释放对象锁。

一个线程调用sleep()不影响其他线程,而wait()会导致当前线程释放锁让其他线程有机会运行。

## 可以直接调用 Thread 类的 run 方法吗？

可以，但是不建议。

正确方式应该是：

1. 创建Thread类的子类，重写run()方法。
2. 创建Thread类的示例
3. 调用start()方法启动线程，进入就绪状态。

而直接调用run方法会导致：

1. run()方法在当前线程执行，而不是线程中执行，失去了多线程的意义。

‍
